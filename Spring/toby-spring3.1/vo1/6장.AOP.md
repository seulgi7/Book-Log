# 6장. AOP

> AOP
>
> - IoC/DI, 서비스의 추상화와 더불어 스프링의 3대 기반기술의 하나
> - 스프링에 적용된 가장 인기 있는 AOP의 적용 대상 : 선언전 트랜잭션 기능 

서비스 추상화를 통해 많은 근본적인 문제를 해결했던 트랜잭션 경계설정 기능을 AOP를 이용해 더욱 세련되고 깔끔한 방식으로 바꿔보자.



## 6.1 트랜잭션 코드의 분리

서비스 추상화 기법을 적용한 UserService 코드의 문제점 

​	→ 트랜잭션 경계설정과 비즈니스 로직이 공존.

### 6.1.1 메소드 분리

- 트랜잭션 경계설정과 비즈니스 로직이 공존하는 메소드

  ```java
  public class UserService{
    ...
    private PlatFormTransactionManager transactionManager;
    
    public void setTransactionManager(PlatFormTransactionManager transactionManager){
      this.transactionManager = transactionManager;
    }
   
    public void upgradeLevels(){
      /* ----트랜잭션 경계설정---- */
      	TransactionStatus status 
          = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
      /* --------------------- */
      	
      	try{
          /* --비즈니스 로직-- */
          List<User> users = userDao.getAll();
          for(User user : users){
            if(canUpgradeLevel(user)){
              upgradeLevel(user);
            }
      		}
          /* ------------- */
          /* ----트랜잭션 경계설정---- */
          this.transactionManager.commit(status);
        }catch(RuntimeException e){
          this.transactionManager.rollback(status);
          throws e;
        }
      /* --------------------- */
    }
    ...
  }
  ```

  - 뚜렷하게 2가지 종류의 코드가 구분되어 있음.

    - 비즈니스 로직 코드를 사이에 두고 트랜잭션 시작과 종료를 담당하는 코드가 앞뒤에 위치하고 있음.

  - 트랜잭션 경계설정의 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없음.

    → 완벽하게 독립적인 코드.

    

- 비즈니스 로직과 트랜잭션 경계설정의 분리.

  비즈니스 로직을 담당하는 코드를 메소드로 추출해서 독립시킴.

  ```java
  public void upgradeLevels(){
      	TransactionStatus status 
          = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
      	
      	try{
          upgradeLevelsInternal();
          this.transactionManager.commit(status);
        }catch(RuntimeException e){
          this.transactionManager.rollback(status);
          throws e;
        }
    }
  
  /* 분리된 비즈니스 로직 코드 → 트랜잭션 적용하기 전과 동일함. */
  public void upgradeLevelsInternal(){
    List<User> users = userDao.getAll();
    for(User user : users){
      if(canUpgradeLevel(user)){
        upgradeLevel(user);
      }
    }
  }
  ```

  - 문제점 : 여전히 트랜잭션을 담당하는 기술적인 코드가 버젓이 자리잡고 있음.

    →  트랜잭션 코드를 클래스 밖으로 뽑아내자.

## 6.1.2.  DI를 이용한 클래스의 분리

#### DI 적용을 이용한 트랜잭션 분리

- 문제점

  - 트랜잭션 코드를 UserService 클래스 밖으로 빼버리면 UserService를 직접 사용한는 클라이언트 코드에서는 트랜잭션이 빠진 UserService를 사용하게 될것.

    → 구체적인 구현 클래스를 직접 참조하는 경우의 전형적인 단점.

- DI 적용을 통해 분리한 트랜잭션을  간접적으로 사용.

  > DI의 기본 아이디어
  >
  > - 실제 사용할 오브젝트의 클래스 정체는 감춘 채 인터페이스를 통해 간접적으로 접근 가능.
  >
  >   → 구현 클래스는 얼마든지 외부에서 변경 가능.

  - 기존 : UserService 클래스와 클라이언트의 직접 연결을 통한 강한 결합

    <img src="./img/6-1_UserService 클래스와 클라이언트의 직접 연결을 통한 강한 결합.jpg" alt="6-1_UserService 클래스와 클라이언트의 직접 연결을 통한 강한 결합" style="zoom:50%;" />

  - 조치 : UserService 인터페이스 도입을 통해 약한 결합을 갖는 유연한 구조

    <img src="./img/6-2_UserService 인터페이스 도입을 통해 약한 결합을 갖는 유연한 구조.jpg" alt="6-2_UserService 인터페이스 도입을 통해 약한 결합을 갖는 유연한 구조" style="zoom:50%;" />

    - 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 런타임 시에 DI를 통해 적용하는 방법
      - 사용 이유: 일반적으로 구현 클래스를 바꿔가면서 사용하기 위해.

  - 최종 조치 : 트랜잭션 경계설정을 위한 UserServiceTx의 도입.

    <img src="./img/6-2_트랜잭션 경계설정을 위한 UserServiceTx의 도입.jpg" alt="6-2_트랜잭션 경계설정을 위한 UserServiceTx의 도입" style="zoom:40%;" />

    - UserService를 구현한 또 다른 구현 클래스 UserServiceTx를 만든다.
      - 단지 트랜잭션의 결계설정이라는 책임을 맡고 있음.
      - 스스로 비즈니스 로직을 담고 있지 않기 때문에 또 다른 비즈니스 로직을 담고 있는 UserService의 구현클래스(UserServiceImpl)에 실제적인 로직 처리 작업은 위임하는 것.
      - 그 위임을 위한 호출 작업 이전과 이후에 적절한 트랜잭션 경계를 설정하면, 트랜잭션이 적용된 비즈니스 로직의 구현을 할 수 있음.

  ### 

#### UserService 인터페이스 도입

1. 기존의 UserService 클래스를 UserServiceImpl로 이름 변경

2. 클라이언트가 사용할 로직을 담은 핵심 메소드만 UserService 인터페이스로 만든 후 UserSerivceImpl이 구현하도록 만듬.

   - UserService 인터페이스

     ```java
     public interface UserService{
       void add(User user);
       void upgradeLevels();
     }
     ```

   - 트랜잭션 코드를 제거한 UserService 구현 클래스

     ```java
     public class UserServiceImpl implements UserService{
       UserDao userDao;
       MailSender mailSender;
       ...
         
     	public void upgradeLevels(){
         List<User> users = userDao.getAll();
         for(User user:users){
           if(canUpgradeLevel(user)){
             upgradeLevel(user);
           }
         }
           
       }
     }
     ```

     - UserService 인터페이스의 구현 클래스인 UserServiceImpl은 기존 UserService 클래스의 내용을 대부분 그대로 유지하면 됨.

       단,  트랜잭션 관련된 코드는 독립시키기로 했으니 모두 제거.

       

## 6.2 고립된 단위 테스트

### 6.2.3 단위 테스트와 통합테스트

#### 단위 테스트

- 중요한 것 : 하나의 단위에 초점을 맞춘 테스트라는 점.
- upgradeLevels() 테스트 처럼 '테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트 하는 것'.

#### 통합 테스트

- 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트 하거나 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트.
- 두 개이 상의 단위가 결합해섯 동작하면서 테스트가 수행되는 것.
  - 스프링의 테스트 컨텍스트 프레임워크를 이용해서 컨텍스트에서 생성되고 DI된 오브ㅔㄱ트를 테스트하는 것도 통합 테스트.

#### 단위 테스트와 통합 테스트 중에서 어떤 방법을 선택할 지에 대한 가이드라인.

- 항상 단위 테스트를 먼저 고려한다.

- 하나의 클래스나 성격과 목적이 같은 긴밀한 클래스 몇 개를 모아서 외부와의 의존관계를 모두 차단하고 필요에 따라 스텁이나 목 오브젝트 등의 테스트 대역을 이용하도록 테스트를 만든다.

  - 단위 테스트의 장점 : 가장  빠른시간에 효과적인 테스트를 작성하기에 유리함.
    - 왜? 테스트 작성도 간단하고 실행 속도도 빠르며 테스트 대상 외의 코드나 환경으로부터 테스트 결과에 영향을 받지않기때문에.

- 외부 리소스를 사용해야만 가능한  테스트는? 통합 테스트로 만든다.

- 단위 테스트로 만들기 어려운 코드가 있다.

  - 대표적인 코드 : DAO

    - DAO는 그 자체로 로직을 담고 있기보다는 DB를 통햏 로직을 수행하는 인터페이스와 같은 역할을 함.

      - DAO는 DB까지 연동하는 테스트로 만드는 편이 효과적.

        - 왜 ? SQL을 JDBC를 통해 실행하는 코드만으로는 고립된 테스트를 작성하기가 힘들다.

        작성한다고 해도 가치가 없는 경우가 대부분.

        →  DB를 사용하는 테스트는 DB에 테스트 데이터를 준비하고, DB에 직접 확인을 하는 등의 부가적인 작업 필요함.

- DAO 테스트:  통합 테스트로 분류 됨.

  - 왜? DB라는 외부 리소스를 사용하기 떄문.

  - 하지만, 코드에서 보자면 하나의 기능 단위를 테스트 하는 것이기도 함.

  - DAO를 테스트를 통해 충분히 검증해두면, DAO를 이용하는 코드느 DAO 역할을 스텁이나 목 오브ㅔㄱ트로 대체해서 테스트할 수 있음.

    이후에 실제 DAO와 연동했을 때도 바르게 동작하리라고 확신할 수 있음.

    물론 각각 단위 테스트가 성공했떠라도 여러 개의 단위를 연결해서 테스트ㅎ면 오류가 발생할 수도 잇음.

    하지만 충분한 단위 테스트를 거친다면 통합 테스트에서 오류가 발생할 확률도 죽어들고 발생한다고 하더라도 쉽게  처리할 수 있음.

- 여러개의 단위가 의존관계를 가지고 동작할 때를 위한 통합테스트는 필요하다.

  다만, 단위 테스트를 충분히 거쳤다면 통합 테스트의 부담은 상대적으로 줄어든다.

- 단위 테스트를 만들기가 복잡하다고 판단되는 코드는 처음부터 통합 테스트를 고려해 본다. 이때도 통합 테스트에 참여하는 코드 중에서 간으한 한 많은 부분을 미리 단위 테스트로 검증해두는 게 유리함.

- 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합테스트.

  - 가능하면 스프링의 지원 없이 직접 코드 레벨읭 DI를 사용하면서단위 테스트를 하는 게 좋겠지만 스프링의 설정 자체도 테스트 대상이고, 스프링을 이용해 좀 더 추상적인 레벨에서 테스트해야 할 경우도 종종 잇음.

     → 스프링의 테스트 컨텍스트  프레임워크를 이ㅇㅇ해 통합 테스트를 작성함.



### 6.2.4 목 프레임워크

## 6.3 다이내믹 프록시와 팩토리 빈

### 6.3.1 프록시와 프록시패턴, 데코레이터 패턴

- 프록시(proxy)

  - 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장에해서 클라이언ㅇ트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 한다고 해서 프록시라 부름.

  - 특징 

    -  타깃과 같은 인터페이스를 구현했다는 것.

    - 타깃을 제어할 수 있는 위치에 있다는 것

      > 타깃(target) 또는 실체(real subject)
      >
      > - 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트.

  - 클라이언트가 프록시를 통해 타깃을 사용하는 구조

  ![6-10 프록시와 타깃](./img/6-10 프록시와 타깃.jpg)

  - 사용목적에 따른 구분

    1. 클라이언트가 타깃에 접근하는 방법을 제어하기 위해.
    2. 타깃에 부가적인 기능을 부여해주기 위해.

    →  공통점 : 대리 오브젝트라는 개념의 프록시를 두고 사용.

    →  차이점: 목적에 따라서 디자인패터에서는 다른 패턴으로 구분함.

#### 데코레이터 패턴

- 데코레이터 패턴
  -  타깃에 부가적인 기능을런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴.
    - 다이내믹하게 기능을 부가한다? 컴파일 시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있찌 않다는 뜻.
  - 특징
    - 프록시가 꼭 한개로 제한되지 않음
    - 프록시가 직접 타깃을 고정시킬 필요가 없음.

#### 프록시 패턴

- 프록시 패턴
  - 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가리킴.
  - 특징
    - 타깃의 기능을 확장하거나 추가하지 않음.
    - 클라이언트가 타깃에 접근하는 방식을 변경해줌
  - 타깃 오브젝트를 생성하기 복잡하거나 당장 필요하지 않은 경우? 꼭 필요한 시점까지 오브젝트를 생성하지 않는 편이 좋음.

### 6.3.2 다이네믹 프록시

#### 프록시의 구성과 프록시 작성의 문제점

- 프록시 기능의 구성
  1. 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임함.
  2. 지정된 요청에 대해서는 부가기능을 수행함.
- 프록시의 역할 : 위임과 부가작업
- 프록시를 만들기가 어려운 이유는 ?
  1. 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다
  2. 부가기능 코드가 중복될 가능성이 많다.

#### 리플렉션

- 다이내믹 프록시는 리플렉션 기능을 이요해서 프록시를 만들어줌
  - 리플렉션 : 자바의 코드 자체를 추상화해서 접근하도록 만든 것.

​				
- - 





### 6.3.4 다이내믹 프록시를 위한 팩토리 빈

#### 팩토리 빈

- 스프링의 클래스 정보를 가지고 디폴드 생성자를 통해 오브젝트를 만드는 방법.

- 팩토리 빈? 스프링을 대신해서 오브젝트의 생성 로직을담당하도록 만들어진 특별한 빈.

- 방법

  - 가장 간단한 방법 : 스프링의 FactoryBean이라는 인터페이스를 구현하는 것.

    - 세가지 메소드로 구성되어 있음.

      ```java
      package org.springframework.beans.factory;
      
      public interface FactoryBean<T>{
        T getObject() throws Exception;//빈 오브젝트를 생성해서 돌려준다.
        Class<? extends T> getObjectType();//생성되는 오브젝트의 타입을 알려준다.
        boolean isSingleTone();//getObject()가 돌려주는 오브젝트가 항상 같은 싱글톤 오브젝트인지 알려줌.
      }
      ```

    - FactoryBean인터페이스를 구현한 클래스를 스프링의 빈으로 등록하면 팩토리 빈으로 동작함.

#### 팩토리 빈의 설정 방법

```xml
<bean id="message" class="springbook.learningtest.spring.factorybean.MessageFactoryBean">
	<property name="text" value="Factory Bean"/>
""</bean>
```



#### 다이내믹 프록시를 만들어주는 팩토리 빈

- Proxy의 newProxyInstance() 메소드를 통해서만 생성이 가능한 다이내믹 프록시 오브젝트는 일반적인 방법으로는 스프링의 빈으로 등록할 수 없다. 대신 팩토리 빈을 사용하면 다이내믹 프록시 오브젝트를 스프링의 빈으로 만들어 줄 수 있음.

  → 팩토리 빈의 getObject() 메소드에 다이내믹 프록시 오브젝트를 만들어주는 코드를 넣으면 되기 때문이다.



#### 트랜잭션 프록시 팩토리 빈

- 팩토리 빈이 만드는 다이내믹 프록시는 구현 인터페이스나, 타깃의 종류에 제한이 없음.

  → UserService 외에도 트랜잭션 부가기능이 필요한 오브젝트를 위한 프록시를 만들 때 얼마든지 재사용이 가능함.

  ​     설정이 다른 여러개의 TxProxyFactoryBea 빈을 등록하면됨.

### 6.3.5 프록시 팩토리 빈 방식의 장점과 한계

#### 프록시 팩토리 빈 방식의 장점

- 데코레이션 패턴이 적용된 프록시의 한계 2가지 극복가능

  1. 프록시를 적용할 대상이 구현하고 있는 인터페이스를 구현하는 프록시 클래스를 일일이 만들어야한다는 번거로움.
  2. 부가적인 기능이 여러 메소드에 반복적으로 나타나게 돼서 코드 중복의 문제가 발생한다

  → 하나의 핸들러 메소드를 구현하는 것만으로도 수많은 메소드에 부가기능을 부여해줄 수 있으니 부가기능 코드의 중복 문제도 사라짐.





### 6.4 스프링의 프록시 팩토리 빈

#### 6.4.1 ProxyFactoryBean

- 스프링은 트랜잭션 기술과 메일 발송 기술에 적용했던 서비스 추상활르 프록시 기술에도 동일하게 적용하고 잇음.
- 스프링은 프록시 오브젝트를 생성하느 기술을 추상화한 팩토리 빈을 제공해줌.

### 6.4.2 ProxyFactoryBean적용

TxProxyFactoryBena을 이제 스프링이 제공하느 ProxyFactoryBean을 이용하도록 수정.

#### TransactionAdvice

부가기능을 담당하는 어드바이스는 MethodInterceptor라는 Advice서브 인터페이스를 구현에서 만든다.

JDK 다이내믹 프록시 방식으로 만든 TransactionHandler의 코드에서 타깃과 메소드 선정 부분을 제거해주면 됨.

#### 스프링의 XML 설정파일

트랙잭션 기능 적용을 위해 transactionManager만 DI해주면 됨.

- 트랜잭션 어드바이스 빈 설정

  ```xml
  <bean id="transactionAdvice" class="springbook.user.service.TransactionAdvice">
    <propery name="transactionManager" ref="transactionManager"/>
  </bean>
  ```

- 포인트컷 빈 등록 : 트랜잭션 적용 메소드 선정을 위함.

  ```xml
  <bean id="transactionPointcut" class="org.springframework.aop.support.NameMatchMethodPointcout">
    <propery name="mappedName" ref="upgrade"/>
  </bean>
  ```

- 어드바이저 빈 설정 ; 어드바이스와 포인트 컷을 담을 어드바이저를 빈으로 등록.

  ```xml
  <bean id="transactionAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor">
    <propery name="advice" ref="transactionAdvice"/>
    <propery name="pointcut" ref="transactionPointcut"/>
  </bean>
  ```

  

#### 어드바이스와 포인트 컷의 재상용

PactoryBean은 스프링의 Di와 템플릿/콜백 패턴, 서비스 추상화 등의 기법이 모두 적용된것.

→ 독립적이며, 여러 프록시가 공유할 수 있는 어드바이스와 포인트 컷으로 확장 기능을 분리할 수 있었다.


## 6.5 스프링 AOP

### 6.5.1 자동 프록시 생성

한 가지 해결할 과제 남음 ; 프록시 팩토리 빈 방식의 접근 방법의 한계 2가지

1. 부가기능이 타깃 오브젝트마다 새로 만들어지는 문제 

   → 해결 : 스프링 ProxyFactoryBean

2. 부가기능이 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정정보를 추가해주는 부분.



#### 빈 후처리기를 이용한 자동 프록시 생성기

> 빈 후처리기 : 스프링 빈 오브젝트로 만들어지고 난 후에, 빈 오브젝트를 다시 가공할 수 있게 해줌.

- DefaultAdvisorAutoProxyCreator : 스프링이 제공하는 빈 후처리기 

  - 어드바이저를 이용한 자동 프록시 생성기
  - 빈 후처리기를 스프링에 적용하는 방법 : 빈 후처리기 자체를 빈으로 등록.
    - 스프링은 빈 후처리기가 빈으로 등록되어 있으면 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업을 요청함.

- 빈 후처리기를 이용한 자동 프록시 생성 방법 

  1. DefaultAdvisorAutoProxyCreator 빈 후처리기가 등록되어 있으면 스프링은 빈 오브젝트를 만들 때마다 후처리기에 빈을 보낸다.
  2. DefaultAdvisorAutoProxyCreator는 빈으로 등록된 모든 어드바이저 내의 포인트컷을 확인하여 적용 대상인지 확인.
  3. 적용 대상이면 내장된 프록시 생성기에게 현재 빈에대한 프록시를 만들게 한다.
  4. 만들어진 프록시에 어드바이저를 연결해준다.
  5. 빈 후처리기는 프록시가 생성되면 원래 컨테이너가 전달해준 빈 오브젝트 대신 프록시 오브젝트를 컨테이너에게 돌려준다.

  

  →  적용한 빈을 설정하는 로직이 추가된 포인트 컷이 담긴 어드바이저를 등록하고  빈 후처리기를 사용하면 일일이 ProxyFactoryBean 빈을 등록하지 않아도 타깃 오브젝트에 자동으로 프록시가 적용되게 할 수 있음.



### 확장된 포인트컷

사실 포인트 컷은 두 가지 기능을 가지고 있다.

```java
public interface Pointcut{
  ClassFilter getClassFilter();                  //프록시를 적용할 클래스인지 확인해 준다.
  MethodMatcher getMethodMatcher(); // 어드바이스를 적용할 메소드인지 확인해준다.
}
```

포인트 컷은 클래스 필터와 메소드 매처 두 가지를 돌려주는 메소드를 갖고 있다. 

실제 포인트컷의 선별 로직은 이 두가지 타입의 오브젝트에 담겨 있다.

- 기존의 NamedMatchMethodPointcut은 메소드 선별 기능만 가진 포인트컷이다.
- 메소드만 선별하기 때문에 클래스의 종류는 상관없이 메소드만 판별했다.
- why? 기존의 코드에서는 타깃이 이미 정해져 있기 때문

### 6.5.2 DefulatAdvisorAutoProxyCreator 적용

프록시 자동생성 방식에서 사용할 포인트컷을 만드는 방법을 실제로 적용해 보자.

#### 클래스 필터를 적용한 포인트컷 작성

NameMatchMethodPointcut을 상속해서 프로퍼티로 주어진 이름 패턴을 가지고 클래스 이름을 비교하는 ClassFilter를 추가하도록 만든다.

```java
public class NameMatchClassMethodPointcut extends NameMatchMethodPointcut{
  public void setMappedClassName(String mappedClassName){
    this.setClassFilter(new SimpleClassFilter(mappedClassName));
    // 모든 클래스를 허용하던 디폴트 클래스 필터를 프로퍼티로 받은 클래스 이름을 이용해서 필터를 만들어 덮어씌운다.
  }

  static class SimpleClassFilter implements ClassFilter{
    String mappedName;

    private SimpleClassFilter(String mappedName) {
      this.mappedName = mappedName;
    }

    public boolean matches(Class<?> clazz){
      // * 가 들어간 문자열 비교를 지원하는 스프링의 유틸리티 메소드.
      // *name , name* , *name* 세 가지 방식을 모두 지원.
      return PatternMatchUtils.simpleMatch(mappedName, clazz.getSimpleName());
    }
  }
}
```



#### 어드바이저를 이용하는 자동 프록시 생성기 등록

- DefaultAdvisorAutoProxyCreator는 등록된 빈 중에서 Advisor 인터페이스를 구현한 것을 모두 찾는다. 그리고 적용 가능한 빈에 대해 어드바이저 포인트컷을 적용하면서 프록시 적용 대상을 선정한여 원래 빈 오브젝트와 바꿔치기 한다.
-  따라서 타깃 빈에 의존한다고 정의한 다른 빈들은 프록시 오브젝트를 대신 DI 받게 된다.

```xml
<bean class = “org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreaotr” />
<!-- 다른 빈에서 참조되거나 코드에서 빈 이름으로 조회될 필요가 없는 빈이라면 아이디 등록을 하지 않아도 된다 --->
```

#### 포인트컷 등록

기존의 포인트컷 설정을 삭제하고 새로 만들 클래스 필터 지원 포인트컷을 빈으로 등록한다.

```xml
<bean id=”transactionPointcut” class=”springbook.service.NameMatchClassMethodPointcut”>
  <property name=”mappedClassName” value=”*ServiceImpl” /> <!-- 클래스 이름패턴--->
  <property name=”mappedName” value=”upgrade*” /> <!-- 메소드 이름패턴 --->
</bean>
```



#### 어드바이스와 어드바이저

- 어드바이스인 transactionAdvice 빈의 설정은 수정할게 없다. 

- 어드바이저인 transactionAdvisor 빈도 수정할 필요는 없다. 

- 하지만 어드바이저로 사용되는 방법이 바뀌었다는 사실은 기억해두자. 

→ 기존: ProxyFactoryBean으로 등록한 빈에서 transactionAdvisor를 명시적으로 DI함. 

→ 현재: DefaultAdvisorAutoProxyCreator에 의해 어드바이저가 자동 수집되고, 프록시 대상 선정 과정에 참여하여, 자동생성된 프록시에 다이내믹하게 DI 돼서 동작하는 어드바이저가 됨.



### 자동생성 프록시 확인

DefaultAdvisorAutoProxyCreator에 의해 userService 빈이 프록시로 바꿔치기됐다면 getBean(“userService”)로 가져온 오브젝트는 TestUserService 타입이 아니라 JDK의 Proxy타입일 것이다. 모든 JDK 다이내믹 프록시 방식으로 만들어지는 프록시는 Proxy 클래스의 서브클래스이기 때문이다.

```
@Test
public void advisorAutoProxyCreator(){
  assertThat(testUserService, is(java.lang.reflect.Proxy.class));
}
```

------

##  

## 6.5.3 포인트컷 표현식을 이용한 포인트컷

### 포인트컷 표현식

AspectJExpressionPointcut은 클래스와 메소드의 선정 알고리즘을 포인트컷 표현식을 이용해 한 번에 지정할 수 있게 해준다. AspectJ의 일부 문법을 확장해서 사용하는것이다. 그래서 이를 AspectJ 포인트컷 표현식이라고도 한다.

## 포인트컷 표현식 문법

execution([접근제한자 패턴] 타입패턴 [타입패턴.]이름패턴 (타입패턴 | ”..”, ...) [throws 예외패턴])

● [접근제한자 패턴] : public, private 등 (생략가능)

● 타입패턴 : 리턴 값의 타입 패턴

● [타입패턴.]: 패키지와 클래스 이름에 대한 패턴. 생략가능

● 이름패턴 : 메소드 이름 패턴

● (타입패턴 | ”..”, ...) : 파라미터의 타입 패턴을 순서대로 넣을 수 있다. 와일드카드를 이용해 파라미터 개수에 상관없는 패턴을 만들 수 있다.

● [throws 예외 패턴] : 예외 이름 패턴

| **execution(\* minus(int,int ))**                            |
| ------------------------------------------------------------ |
| 리턴 타입은 상관없이 minus라는 메소드 이름, int파라미터를 두개 가진 모든 메소드를 선정하는 포인트컷 표현식 |

| **execution(\* minus(..))**                                  |
| ------------------------------------------------------------ |
| 리턴 타입과 파라미터의 종류, 개수 상관없이 minus라는 메소드이름을 가진 모든 메소드를 선정하는 포인트컷 표현식 |

| **execution(\* \*(..))**                                     |
| ------------------------------------------------------------ |
| 리턴 타입, 파라미터, 메소드 이름에 상관없이 모든 메소드 조건을 다 허용하는 포인트컷 표현식 |

 

### 포인트컷 표현식을 이용하는 포인트컷 적용

execution() 외에도 몇 가지 표현식 스타일이 있다.

- bean() : bean(*Service) 라고 쓰면 아이디가 Service로 끝나는 모든 빈을 선택한다. ( 클래스와 메소드라는 기준X)
- @annotation() : 특정 애노테이션이 적용된 메소드를 선정할 수 있다.

- 기존

  ```properties
  <property name="mappedClassName" value="*ServiceImpl" />
  <property name="mappedName" value="upgrade*" />
  ```

- **포인트컷 표현식을 이용한 빈 설정**

  ```properties
  <bean id=”transactionPointcut” class=”org.springframework.aop.aspectj.AspectJExpressionPointcut”>
    <property name=”expression” value=”execution(* *..*ServiceImpl.upgrade*(..))” />
  </bean>
  ```

   

### 타입 패턴과 클래스 이름 패턴

기존의 TestUserService 였던 테스트용 UserService 구현 클래스의 이름을 이름 패턴에 맞추려고 TetstUserServiceImpl로 변경하였다.

 

이를 다시 TetsUserService로 바꾸어도 execution(* *..*ServiceImpl.upgrade*(..)) 로 되어있는 포인트컷의 선정대상에 포함된다.

 

why? 

> 포인트컷 표현식의 클래스 이름에 적용되는 패턴은 클래스 이름 패턴이 아니라 타입 패턴이기 때문이다. 
> TestUserService의 클래스 이름은 TestUserService 이지만, 타입을 따져보면 TestUserService 클래스 이고, 슈퍼클래스인 UserServiceImpl, 구현 인터페이스인 UserService 세 가지가 모두 적용된다. 

------

## 6.5.4 AOP란 무엇인가?



### 트랜잭션 서비스 추상화

트랜잭션 경계설정 코드를 비즈니스 로직을 담은 코드에 넣으면서 맞닥뜨린 첫 번째 문제는 특정 트랜잭션 기술에 종속되는 코드가 돼버린다는 것이었다. 

그래서 트랜잭션 적용이라는 추상적인 작업 내용은 유지한 채로 구체적인 구현 방법을 자유롭게 바꿀 수 있도록 서비스 추상화 기법을 적용했다.

결국 DI를 통해 무엇을 하는지는 남기고, 그것을 어떻게 하는지를 분리한 것이다.

### 프록시와 데코레이터 패턴

여전히 비즈니스 로직 코드에는 트랜잭션을 적용하고 있다. 그래서 DI를 이용한 데코레이터 패턴을 적용했다. 클라이언트가 인터페이스와 DI를 통해 접근하도록 설계하였다. 트랜잭션을 처리하는 코드는 일종의 데코레이터에 담겨서, 클라이언트와 비즈니스로직을 담은 타깃 클래스 사이에 존재하도록 만들었다. 그래서 클라이언트가 프록시 역할을 하는 트랜잭션 데코레이터를 거쳐서 타깃에 접근할 수 있게 됐다.

### 다이내믹 프록시와 프록시 팩토리 빈

비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여하는 코드를 넣어 프록시 클래스를 만드는 작업이 오히려 불편한 점이 됐다. 그래서 프록시 클래스 없이도 프록시 오브젝트를 런타임 시에 만들어주는 JDK 다이내믹 프록시 기술을 적용했다.

하지만 동일한 기능의 프록시를 여러 오브젝트에 적용할 경우 오브젝트 단위로는 중복이 일어나는 문제는 해결하지 못했다.

스프링의 프록시 팩토리 빈을 이용해서 다이내믹 프록시 생성 방법에 DI를 도입했다.

### 자동 프록시 생성 방법과 포인트컷

트랜잭션 적용대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해줘야 한다는 부담이 남아있다. 이를 해결하기 위해서 스프링 컨테이너의 빈 생성 후처리 기법을 활용해 컨테이너 초기화 시점에서 자동으로 프록시를 만들어주는 방법을 도입했다.

### 부가기능의 모듈화

트랜잭션적용 코드는 기존에 써왔던 방법으로는 간단하게 분리해서 독립된 모듈로 만들 수가 없다.

부가기능이기 때문에 독립적인 방식으로 적용되기 어렵기 때문이다. 그래서 핵심기능의 곳곳에서 나타나는 부가기능을 어떻게 독립적인 모듈로 만들 수 있을까 고민했고, 

위에서 나온 개념들이 이런 문제를 해결하기 위해 적용한 대표적인 방법이다.

결국 지금까지 해온 모든 작업은 핵심기능에 부여되는 부가기능을 효과적으로 모듈화 하는 방법을 찾는 것이었고, 어드바이스와 포인트컷을 결합한 어드바이저가 단순하지만 이런 특성을 가진 모듈의 원시적인 형태로 만들어지게 됐다.

### AOP: 애스펙트 지향 프로그래밍

애스펙트는 부가될 기능을 정의한 코드인 어드바이스와, 어디에 적용할지를 결정하는 포인트컷을 함께 갖고 있다.

애스펙트는 단어 그대로 애플리케이션을 구성하는 한 가지 측면이라고 생각 할 수 있다.



![img](https://blog.kakaocdn.net/dn/bndkbx/btqFIOlgX0r/9bgJh66E6W3zn4oSfNKvE0/img.png)



기존의 코드는 핵심기능과 부가기능이 같이 들어있기에 코드가 복잡하고 지저분했지만, 

이를 입체적구조로 가져가면서 각각 성격이 다른 부가기능은 다른면에 존재하도록 만들었다.

 

이렇게 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법을 AOP 라고 부른다.

마치 OOP(객체지향프로그래밍)의 다른 개념같이 느껴지지만, AOP는 OOP를 돕는 보조적인 기술이지 OOP를 대체하는 개념은 아니다. AOP는 애스펙트를 분리하여, 핵심기능을 설계하고 구현할 때 객체지향적인 가치를 지킬 수 있도록 도와주는 것이라고 보면 된다.



### 6.5.6 AOP의 용어

- 타깃
  - 부가기능을 부여할 대상.
  - 핵심기능을 담은 클래스일 수도 있지만 경우에 따라서는 다른 부가기능을 제공하는 프록시 오브젝트일 수도 있음.
- 어드바이스
  - 타깃에게 적용할 부가기능을 담은 모듈.
  - 오브젝트로 정의하기도 하지만 메소드 레벨에서 정의할 수도 있음.
  - 여러가지 종류가 있음.
    - MehotdInterceptor 처럼 메소드 호출 과정에 전반적으로 참여하기도 함.
    - 예외가 발생했을 때만 동작하는 어드바이스처럼 메소드 호출 과정의 일부에서만 동적하기도 함.

- 조인 포인트(join point)
  - 어드바이스가 적용될 수 있는 위치를 말함.
  - 스프링의 프록시 AOP에서 조인 포인트는 메소드의 실행 단계 뿐.
  - 타깃 오브젝트가 구현한 인터페이스의 모든 메소드는 조인 포인트가 됨.
- 포인트컷
  - 어드바이스를 적용한 조인포인트를 선별하는 작업 또는 그 기능을 정의한 모듈.
  - 스프링 AOP의 조인포인트는 메소드의 실행이므로 스프링의 포인트컷은 메소드를 선정하는 기능을 갖고 있음.
  - 포인트컷 표현식
    - 메소드의 실행이라는의미인 execution으로 시작함.
    - 메소드의 시그니처를 비교하는 방법을 주로 이용함.
  - 메소드 선정이란 결국 클래스를 선정하고 그 안의 메소드를 선정하는 과정을 거치게 됨.
    - 왜? 메소드는 클래스 안에 존재하는 것이기 때문에 
- 프록시
  - 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트
  - DI를 통해 타깃 대신 클라이언트에게 주입되며, 클라이언트의 메소드 호출을 대신 받아서 타깃에 위임해주면서, 그 과정에서 부가기능을 부여함.
  - 스프링은 프록시를 이용해 AOP를 지원함.
- 어드바이저
  - 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트.
  - 어떤 부가기능(어드바이스)를 어디에(포인트컷) 전달한 것인가를 알고있는 AOP의 가장 기본이 되는 모듈.
  - 스프링은 자동 프록시 생성기가 어드바이저를 AOP 작업의 정보롤 활용함.
  - 어드바이저는 스프링 AOP에서만 사용되는 특별한 용어이고, 일반적인 AOP에서는 사용되지 않음.
- 애스펙트
  - OOP의 클래스와 마찬가지로 애스펙트 AOP의 기본 모듈.
  - 한개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어짐.
  - 보통 싱클톤 형태의 오브젝트로 존재함.
  - 따라서 클래스와 같은 모듈정의와 오브젝트와 같은 실체(인스턴스)의 구분이 특별히 없음.
  - 두가지 모두 애스펙트라고 불림.
  - 스프링의 어드바이저는 아주 단순한 애스펙트라고 볼수도 있음.



### 6.5.7 AOP 네임스페이스

- 스프링의 프록시 방식AOP를 적용하려면 최소한 네 가지 빈을 등록해야한다.

  ### 자동 프록시 생성기

  DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록한다. 다른 빈을 DI하지도 않고 DI되지도 않기 때문에 id도 굳이 필요없다. 빈 오브젝트를 생성하는 과정에 빈 후처리기로 참여한다.

  ### 어드바이스

  부가기능을 구현한 클래스를 빈으로 등록한다. 

  ### 포인트컷

  스프링의 AspectJExpressionPointcu을 빈으로 등록하고 expression 프로퍼티에 포인트컷 표현식을 넣어주면 된다.

  ### 어드바이저

  DefaultPointcutAdvisor 클래스를 빈으로 등록해서 사용한다. 어드바이스와 포인트컷을 프로퍼티로 참조하는 것 외에는 기능은 없다. 자동프록시 생성기에 의해 자동 검색되어 사용된다.

  ### AOP 네이스페이스

  aop 네임스페이스를 선언하면

  ```xml
  <aop:config>
    <aop:pointcut id=”transactionPointcut” expression=”execution(* *..*ServiceImpl.upgrade*(..)) /”>
    <aop:advisor advice-ref=”transactionAdvice” pointcut-ref=”transactionPointcut” />
  </aop:config>
  
  ```

  

  AOP설정 빈을 간단히 바꿀 수 있다.

   

