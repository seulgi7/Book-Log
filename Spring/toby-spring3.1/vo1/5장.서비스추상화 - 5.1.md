# 5장. 서비스추상화

## 5.1 사용자 레벨 관리 기능 추가

사용자 관리 기능으로  사용자의 레벨을 부여하기 위한 레벨 필드를 추가해보자.

### 5.1.1 필드추가

#### Level  이늄

- 숫자 타입을 직접 사용하는 것보다는 자바 5이상에서 제공하는 [이늄(enum)](http://www.google.co.kr)을 이용하는 게 안전하고 편리함.

  - 왜 이늄을 이용하는게 좋은가?

    - Level 이늄은 내부에 DB에 저장할 int 타입의 값을 갖고 있지만, 겉으로는 Level타입의 오브젝트이기 때문에 안전하게 사용할 수 있다.

      - level의 타입이 int 이기 때문에 다른 종류의 정보를 넣는 실수를 해도 컴파일러가 체크해주지 못한다.

        ```java
        user.setLevel(other.getSum());
        ```

        

      - 범위를 벗어난느 값을 넣을 위험도 있다.

        ```java
        user1.setLevel(10000);
        ```

  - 사용자 레벨용 이뇸을 사용한  예제

    ```java
    public enum level{
      BASIC(1), SILVER(2), GOLD(3); //세 개의 이늄 오브젝트 정의
      
      private final int value;
      
      //DB에 저장할 값을 넣어줄 생성자를 만들어둔다.
      Level(int value){
        this.value = value;
      }
      
      //값을 가져오는 메소드
      pubic int intValue(){
        return value;
      }
      
      //값으로부터 Level 타입 오브젝트를 가져오도록 만든 스태틱 메소드
      public static Level valueOf(int value){
        switch(value){
          case 1 : return BASIC;
          case 2 : return SILVER;
          case 3 : return GOLD;
          default : throw new AssertionError("Unknown vlaue: "+ vavlue);
        }
        
      }
    }
    ```

    

#### User  필드 추가

- USER 테이블 추가 필드

  | 필드명 | 타입    | 설정     |
  | ------ | ------- | -------- |
  | Level  | tinyint | not null |

  > **tinyint**
  >
  > - 정수 데이터를 사용하는 정확한 숫자 데이터 형식.
  > - 데이터베이스의 공간을 절약하려면 가능한 모든 값을 안정적으로 포함할 수 있는 가장 작은 데이터 유형을 사용해야하는데 이에 적절함.
  >   - 예를 들어, tinyint는 255세 이상 사는 사람은 아무도 없기 때문에 사람의 나이에 충분합니다.
  >
  > | 데이터 형식 |                             범위                             |  스토리지   |
  > | :---------- | :----------------------------------------------------------: | :---------: |
  > | **tinyint** |                          **0~255**                           | **1바이트** |
  > | smallint    |               -2^15(-32,768) ~ 2^15-1(32,767)                |   2바이트   |
  > | int         |        -2^31(-2,147,483,648) ~ 2^31-1(2,147,483,647)         |   4바이트   |
  > | bigint      | -2^63(-9,223,372,036,854,775,808) ~ 2^63-1(9,223,372,036,854,775,807) |   8바이트   |
  >
  > [[출처] Microsoft : SQL문서 - int, bigint, smallint 및 tinyint(Transact-SQL)]([https://learn.microsoft.com/ko-kr/sql/t-sql/data-types/int-bigint-smallint-and-tinyint-transact-sql?view=sql-server-ver16)).

#### UserDaoJdbc수정

- Level 타입의 level 필드를 사용하는 부분을 눈여겨보자.
  - Level 이늄은 오브젝트이므로 DB에 저장될 수 있는 SQL 타입이 아니다. 따라서 DB에 저장 가능한 **정수형 값으로 변화**해줘야 한다.

### 	5.1.2 사용자 수정 기능 추가

#### 수정 테스트 보완

- JDBC 개발에서 리소스 반환과 같은 기본 작업을 제외하면 가장 많은 실수가 일어나는 곳은 바로 SQL문장이다.  UPDATE 문장에서 WHERE절을 빼먹는 경우처럼 테스트로는 검증하지 못하는 오류가 있을 수 있다.
  - 해결방법
    1. JdbcTemplate의 update()가 돌려주는 리턴 값을 확인 하는 것.
       - JdbcTemplate의 update는 테이블의 내용에 영향을 주는 SQL을 실행하면 영향받은 로우의 개수를 돌려준다.
       - update()테스트라면 리턴 값이 1인지 확인한는 코드를 하나 더 추가해주면 된다.
       - 비록 에러가 발생하지 않고, 원하는 사용자의 정보는 변경됐음을 확인했더라도 영향받은 로우의 개수가 1 이상이라면 update()메소드의 SQL에 문제가 있다는 사실을 알 수  있다.
    2. 테스트를 보강해서 원하는 사용자 외의 정보는 변경되지 않았음을 직접 확인하는 것.
       - 사용자를 두 명 등록해놓고, 그 중 하나만 수정한 뒤에 수정된 사용자와 수정하지 않은 사용자의 정보를 모두 확인하면 됨.

### 5.1.3 UserService.upgradeLevels()

- 레벨 관리 기능을 구현을 위한 사용자 관리 로직은 어디다 두는 것이 좋을까?
  - 사용자 관리 비즈니스 로직을 담을 클래스를 하나 추가하자. ex) UserService 클래스
    - DAO는 어떻게 가져오고 조작할지를 다루는 곳이지 비즈니스 로직을 두는 곳이 아니다.

### 5.1.5 코드 개선

- 작성한 코드를 살펴 볼때는 다음과 같은 질문을 해볼 필요가 있다.

  - 코드에 중복된 부분은 없는가?

    - 메소드는 점점 길어지고 복잡해지며,  갈수록 이해하고 관리하기가 힘들어진다.

      지저분해지는 코드 탓에 찾기 힘든 버그가 숨어들어 갈 가능성이 높아질 것이다.

  - 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?

  - 코드가 자신이 있어야 할 자리에 있는가?

    - 객체지향적인 코드는?
      - 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다. 
      - 오브젝트에게 데이터를 요구하지 말고 작업을 요청하라는 것이 객체지향 프로그래밍의 가장 기본이 되는 원리이기도 하다.

  - 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?


