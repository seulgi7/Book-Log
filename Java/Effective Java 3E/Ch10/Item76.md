# 아이템76. 가능한 한 실패 원자적으로 만들라.

## 실패 원자적(failure-atomic)

- 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지하는 특성.

## 메서드를 실패 원자적으로 만드는 방법

방법은 다양하다.

1. 가장 간단한 방법 : 불변 객체(아이템17)로 설계하는 것.

   - 불변 객체는 태생적으로 실패 원자적.

     →  불변 객체의 상태는 생성 시점에 고정되어 절대 변하지 않기 때문.

   - 메서드가 실패하면 새로운 객체가 만들어지지는 않을 수 있으나 기존 객체가 불안정한 상태로 빠지는 일은 결코 없음.

2.  작업 수행에 앞서 매개변수의 유효성을 검사하는 것(아이템 49).

   - 가변 객체의 메서드를 실패 원자적으로 만드는 가장 흔한 방법.

   - 객체의 내부 상태를 변경하기 전에 잠재적 예외의 가능성 대부분을 걸러낼 수 있는 방법.

     ```java
     pulic Object pop(){
       //처음의 if문에서 size의 값을 확인하여 0이면 예외를 던진다.
       if(size == 0)
         throw new EmptyStackException(); 
     	Object result = elements[--size];
       elements[size] = null; // 다 쓴 참조 해제
       return result;
     }
     ```

   - 계산을 수행해보기 전에는 인수의 유효성을 검사해볼 수 없을 때 앞서의 방식에 덧붙여 쓸 수 있는 기법 : 실패할 가능성이 있는 모든 코드를, 객체의 상태를 바꾸는 코드보다 앞에 배치하기.

3. 객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체하는 것.

   - 데이터를 임시 자료구조에 저장해 작업하는 게 더 빠를 때 적용하기 좋은 방식

   - 예

     - 정렬 메서드에서 정렬을 수행하기 전에 입력 리스트의 원소들을 배열로 옮겨 담는다. 배열을 사용하면 정렬 알고리즘의 반복문에서 원소들에 훨씬 빠르게 접근할 수 있기 때문이다. 

       → 성능을 높여 줄 뿐만 아니라 , 혹시나 정렬에 실패하더라도 입력 리스트는 변하지 않는 효과를 얻을 수 있다.

     

4. 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법.

   - 주로 디스크 기반의 내구성을 보장해야 하는 자료구조에 쓰이지만 자주 쓰이지는 않는다.



# **실패 원자성을 보장하기 어려운 경우**

- 실제 개발 상황에서는 실패 원자성을 보장하기 어렵거나, 이를 보장하기 위한 비용이 너무 클 수 있다.
- 예시 1 - ConcurrentModificationException
  - 다중 스레드 환경에서 한 스레드가 컬렉션을 수정하는 도중 다른 스레드가 동일한 컬렉션을 수정하려고 할 때 발생한다.
  - 이런 경우에서는 에러가 발생하더라도 객체가 유지된다고 가정할 수 없으며, 락이나 동기화 같은 추가적인 도구가 필요하다.
- 예시 2 - Error, AssertionError
  - 시스템 레벨의 문제는 일반적인 방법으로 복구가 불가능하므로, 이를 위해 실패 원자성을 보장하려는 시도는 의미가 없다.

### 결론

 **실패 원자성을 지키지 못할 경우, 실패 시 객체 상태를 API 설명에 명시해야 한다.**

