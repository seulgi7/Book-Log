# 7장. 스프링 핵심 기술의 응용

## 7.1 SQL과 DAO의 분리

### 7.1.1 XML 설정을 이용한 분리

- 가장 손쉽게 생각해 볼 수 있는 SQL 분리 방법 : SQL을 스프링의 XML 설정파일로 빼내는 것.

  → SQL을 설정파일에 프로퍼티 값으로 정의해서 DAO에 주입.

#### 개별 SQL 프로퍼티 방식

- 장점 : 코드 수정 없이 XML 파일만 수정해주면 됨.
- 단점 : 매번 새로운 SQL이 필요할 때마다 프로퍼티를 추가하고 DI를 위한 변수와 수정자 메소드도 만들어줘야 함.

#### SQL 맵 프로퍼티 방식

- SQL을 하나의 컬렉션으로 담아두는 방법.

- 맵을 이용하여 키 값을 이용해 SQL 문장을 가져옴.
- 장점
  - 맵을 이용하면 프로퍼티는 하나만 만들어도 되기 대문에 DAO의 코드는 더 간결해짐.
  - SQL이 더 필요하더라도 프로퍼티 추가 없이 설정파일의 맵 정보만 변경하면 됨.

- 단점 
  - 메소드에서 SQL을 가져올 때 문자열로 된 키 값을 사용하기 때문에 오타와 같은 실수가 있어도, 해당 메소드가 실행되기 전에는 오류를 확인하기 힘듦.

### 7.1.2 SQL 제공 서비스

- XML 설정을 이용한 분리의 문제점
  - 데이터 엑세스 로직의 일부인 SQL 문장을 애플리케이션의 구성정보를 가진 설정정보와 함께 두는 건 바람직하지 못함.
  - SQL을 따로 분리해둬야 독립적으로 SQL 문의 리뷰나 SQL 튜닝 작업을 수행하기 편함.
  - 스프링의 설정파일로부터 생성된 오브젝트와 정보는 애플리케이션을 다시 시작하기 전에는 변경이 매우 어려움.
  - 운영 중인 애플리케이션에서 빈번하게 참조되는 맵 내용을 수정할 경우 동시성 문제를 일으킬 수 있음.

​	➣ 독립적인 SQL 제공 서비스 필요함.



#### SQL 서비스 인터페이스 / 스프링 설정을 사용하는 단순 SQL 서비스

-  가장 먼저 할 일? SQL.서비스의 인터페이스를 설계하는 것.
  - 클라이언트인 DAO을 SQL 서비스의 구현에서 독립적으로 만들도록 인터페이스를 사용하고, DI로 구현 클래스의 오브젝트를 주입해주어야 함.
- DAO가 사용할 SQL 서비스의 기능
  -  SQL에 대한 키 값을 전달하면 그에 해당하는 SQL을 돌려주는 것.
- 장점
  - 모든 DAO는 SQL을 어디에 저장해두고 가져오는지에 대해서는 전혀 신경 쓰지 않아도 됨.
    - 구체적인 구현 방법과 기술에 상관없이 SqlService 인터페이스 타입의 빈을 DI 받아서 필요한 SQL을 가져다 쓰기만 하면 됨.
  - sqlService 빈에는 DAO에는 전혀 영향을 주지 않은 채로 당양한 방법으로 구현된 SqlService 타입 클래스를 적용할 수 있음.

## 7.2 인터페이스의 분리와 자기참조 빈

인터페이스로 대표되는 기능을 구현 방법과 확장 가능성에 따라 유연한 방법으로 재구성할 수 있도록 설계할 필요가 있음.

### 7.2.1 XML 파일 매핑

- 문제점 : 스프링의 XML 설정파일에서 <bean> 태그 안에 SQL 정보를 넣어놓고 활용하는 건 좋은 방법 아님.

  → XML문서를 설계해보고, 이 XML 파일에서 SQL을 읽어뒀다가 DAO에게 제공해주는 SQL 서비스 구현 클래스를 만들어보자.

#### JAXB

- JAXB (Java Architecture for XML Binding)

  - XML에 담긴 정보를 파일에서 읽어오는 방법 중 하나.

  - 장점 : XML 문서정보를 거의 동일한 구조의 오브젝트로 직접 매핑해줌.

    - XML 문서의 구조를 정의한 스키마를 이용해서 매핑할 오브젝트의 클래스까지 자동으로 만들어주는 컴파일러도 제공함.
    - 애노테이션에 담긴 정보를 이용해서 XML과 매핑된 오브젝트 트리 사이의 자동변환 작업을 수행해줌.

    

#### SQL 맵을 위한 스키마 작성과 컴파일

- SQL 정보는 키와 SQL의 목록으로 구성된 맵 구조로 만들어두면 편리함.

- 컴파일러가 만들어준 XML 문서 바인딩용 클래스

  - 자바빈 스타일의 접근자와 수정자 메소드를 갖는 프로퍼티와 컬렉션으로 정의되어있음.

    → 어떻게 XML 문서가 오브젝트로 전환되는지 쉽게 파악 가능.

#### 언마샬링

- 언마샬링(unmarshalling) : JAXB에서 XML 문서를 읽어서 자바의 오브젝트로 변환하는 것

- 마샬링(marshalling) : JAXB에서 바인딩 오브젝트를 XML 문서로 변환하는 것

  

### 7.2.2 XML 파일을 이용하는 SQL 서비스

JAXB 를 이용해 XML 문서를 변환하는 방법을 알아봤으니 SqlService에 적용할 차례.

#### SQL 맵 XML 파일

- DAO와 같은 패키지에 두는 것 권장.

- sqlmap.xml

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <sqlmap xmlns="http://www.epril.com/sqlmap" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.epril.com/sqlmap http://www.epril.com/sqlmap/sqlmap.xsd">
    <sql key="userAdd">insert into users(id, name, password, email, level, login, recommend) values(?,?,?,?,?,?)</sql>
    ...
  
  </sqlmap>
  ```

  

#### XML SQL 서비스

sqlmap.xml에 있는 SQL을 가져와 DAO에게 제공해주는 SqlService 인터페이스의 구현 클래스 생성

- XML 문서에서 SQL을 가져올 때? JAXB API 사용
  - 언제 가져올까? 처음에 XML 파일로부터 읽어온 내용을 어딘가에 저장해두고 DAO에서 요청이 올때 사용.
- 방식 : 생성자에서 JAXB를 이용해 XML로 된 SQL 문서를 읽어들이고, 변환된 Sql 오브젝트를 맵으로 저장해뒀다가, DAO의 요청에 따라 SQL을 찾아서 전달

→ SQL 문장을 스프링의 빈 설정에서 완벽하게 분리하는 데 성공.



### 7.2.3 빈의 초기화 작업

- 개선해야할 사항

  - 생성자에서 예외가 발생할 수도 있는 복잡한 초기화 작업을 다루는 것은 좋지 않음.

    - 오브젝트를 생성하는 중에 생성자에서 발생하는 예외는 다루기 힘들고, 상속하기 불편하며, 보안에도 문제가 생길 수 있음.

    → 초기 상태를 가진 오브젝트를 만들어놓고 별도의 초기화 메소드를 사용하는 방법이 바람직.

  - 읽어들일 파일의 위치와 이름이 코드에 고정되어 있음.

    → 외부에서 DI로 설정해줄 수 있게 만들어야 함.

- 스프링의 빈 후처리기를 통한 초기화 메소드 실행.

  - 초기화메소드가 있는 오브젝트는 빈이므로 제어권이 스프링에 있음.

  - 애노테이션을 이용한 빈 설정을 지원해주는 빈 후처리기 사용.

    → context네임스페이스를 사용해서 <<contest:annotation-config/>>태그를 만들어 설정파일에 넣어주면 빈 설정 기능에 사용할 수 있는 특별한 애노테이션 기능을 부여해주는 빈 후처리기들이 등록됨.

- <<context:annotation-config/>> 태그에 의해 등록되는 빈 후처리기가 제공하는 애노테이션.

  - @PostConstruct 

    - java.lang.annotation 패키지에 포함된 공통 애노테이션의 한가지.
    - JavaEE 5나 JDK 6에 포함된 표준 애노테이션.
    - 빈 오브젝트의 초기화 메소드를 지정하는 데 사용.

    →  @PostcConstruct를 초기화 작업을 수행할 메소드에 부여해주면 스프링은 XmlSqlService클래스로 등록된 빈의 오브젝트를 생성하고 DI 작업을 마친 뒤에 @PostConstruct 가 붙은 메소드를 자동으로 실행해줌.

- 스프링 컨테이너의 초기 작업 순서

  ![7-2 스프링 컨테이너의 초기 작업 순서](./img/7-2 스프링 컨테이너의 초기 작업 순서.jpg)



### 7.2.4 변화를 위한 준비 : 인터페이스 분리

- XML 대신 다른 포맷의 파일에서 SQL을 읽어 오게 하려면 지금 방식은 바람직 하지 않음.

  → 유연하게 확장 가능하도록 DI를 적용해보자.

#### 책임에 따른 인터페이스 정의

- 가장 먼저 할 일 : 분리 가능한 관심사 구분

  1. SQL 정보를 외부의 리소스로부터 읽어오는 것.

     → SQL이 담겨 있는 리소스가 어떤 것이든 상관없이 애플리케이션에서 활용 가능하도록 메모리에 읽어들여야 함.

  2. 읽어온 SQL을 보관해두고 있다가 필요할 때 제공해주는 것.
  3. 부가적인 책임 : 서비스를 위해서 한 번 가져온 SQL을 필요에 따라 수정할 수 있게 하는 것.

- SqlService 서비스 오브젝트 구조

  ![7-3 SqlService 서비스 오브젝트 구조](/Users/jangseulgi/Desktop/dev/workspace/study/spring/toby-spring-vol1/img/7-3 SqlService 서비스 오브젝트 구조.jpg)

  - DAO 관점 : SqlService라는 인터페이스를 구현한 오브젝트에만 의존하고 있으므로 달라질 것 없음.

  - SqlService의 구현 클래스가 변경 가능한 책임을 가진 SqlReader와 SqlRegistry 두 가지 타입의 오브젝트를 사용하도록 만든다.

  - 인터페이스를 실제로 정의하기 전에 생각해 볼 한가지 사항

    - SqlReader가 읽어오는 SQL 정보는 다시 SqlRegistry에 전달해서 등록되게 해야 하기 X

      - 왜? 전달 과정 중에 일정한 포맷으로 변환하도록 강제됨.

    - SqlService가 일단 SqlReader에게 데이터를 달라고 요청하고, 다시 SqlRegistry 전략을 제공해주면서 이를 이용해 SQL 정보를 SqlRegistry에 저장하라고 요청O.

      → 특정 포맷으로 변환한 SQL 정보를 주고받을 필요 없이 SqlReader가 직접 SqlRegistry에 SQL 정보를 등록 할 수 있음.

- SqlRegistry에 의존하는 SqlReader 구조

  - SqlReader가 SqlRegistry와 의존관계를 가지고 작업을 진행하도록 만들었을 때의 구조.