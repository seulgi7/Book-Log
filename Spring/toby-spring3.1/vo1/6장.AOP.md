# 6장. AOP

> AOP
>
> - IoC/DI, 서비스의 추상화와 더불어 스프링의 3대 기반기술의 하나
> - 스프링에 적용된 가장 인기 있는 AOP의 적용 대상 : 선언전 트랜잭션 기능 

서비스 추상화를 통해 많은 근본적인 문제를 해결했던 트랜잭션 경계설정 기능을 AOP를 이용해 더욱 세련되고 깔끔한 방식으로 바꿔보자.



## 6.1 트랜잭션 코드의 분리

서비스 추상화 기법을 적용한 UserService 코드의 문제점 

​	→ 트랜잭션 경계설정과 비즈니스 로직이 공존.

### 6.1.1 메소드 분리

- 트랜잭션 경계설정과 비즈니스 로직이 공존하는 메소드

  ```java
  public class UserService{
    ...
    private PlatFormTransactionManager transactionManager;
    
    public void setTransactionManager(PlatFormTransactionManager transactionManager){
      this.transactionManager = transactionManager;
    }
   
    public void upgradeLevels(){
      /* ----트랜잭션 경계설정---- */
      	TransactionStatus status 
          = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
      /* --------------------- */
      	
      	try{
          /* --비즈니스 로직-- */
          List<User> users = userDao.getAll();
          for(User user : users){
            if(canUpgradeLevel(user)){
              upgradeLevel(user);
            }
      		}
          /* ------------- */
          /* ----트랜잭션 경계설정---- */
          this.transactionManager.commit(status);
        }catch(RuntimeException e){
          this.transactionManager.rollback(status);
          throws e;
        }
      /* --------------------- */
    }
    ...
  }
  ```

  - 뚜렷하게 2가지 종류의 코드가 구분되어 있음.

    - 비즈니스 로직 코드를 사이에 두고 트랜잭션 시작과 종료를 담당하는 코드가 앞뒤에 위치하고 있음.

  - 트랜잭션 경계설정의 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없음.

    → 완벽하게 독립적인 코드.

    

- 비즈니스 로직과 트랜잭션 경계설정의 분리.

  비즈니스 로직을 담당하는 코드를 메소드로 추출해서 독립시킴.

  ```java
  public void upgradeLevels(){
      	TransactionStatus status 
          = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
      	
      	try{
          upgradeLevelsInternal();
          this.transactionManager.commit(status);
        }catch(RuntimeException e){
          this.transactionManager.rollback(status);
          throws e;
        }
    }
  
  /* 분리된 비즈니스 로직 코드 → 트랜잭션 적용하기 전과 동일함. */
  public void upgradeLevelsInternal(){
    List<User> users = userDao.getAll();
    for(User user : users){
      if(canUpgradeLevel(user)){
        upgradeLevel(user);
      }
    }
  }
  ```

  - 문제점 : 여전히 트랜잭션을 담당하는 기술적인 코드가 버젓이 자리잡고 있음.

    →  트랜잭션 코드를 클래스 밖으로 뽑아내자.

## 6.1.2.  DI를 이용한 클래스의 분리

#### DI 적용을 이용한 트랜잭션 분리

- 문제점

  - 트랜잭션 코드를 UserService 클래스 밖으로 빼버리면 UserService를 직접 사용한는 클라이언트 코드에서는 트랜잭션이 빠진 UserService를 사용하게 될것.

    → 구체적인 구현 클래스를 직접 참조하는 경우의 전형적인 단점.

- DI 적용을 통해 분리한 트랜잭션을  간접적으로 사용.

  > DI의 기본 아이디어
  >
  > - 실제 사용할 오브젝트의 클래스 정체는 감춘 채 인터페이스를 통해 간접적으로 접근 가능.
  >
  >   → 구현 클래스는 얼마든지 외부에서 변경 가능.

  - 기존 : UserService 클래스와 클라이언트의 직접 연결을 통한 강한 결합

    <img src="./img/6-1_UserService 클래스와 클라이언트의 직접 연결을 통한 강한 결합.jpg" alt="6-1_UserService 클래스와 클라이언트의 직접 연결을 통한 강한 결합" style="zoom:50%;" />

  - 조치 : UserService 인터페이스 도입을 통해 약한 결합을 갖는 유연한 구조

    <img src="./img/6-2_UserService 인터페이스 도입을 통해 약한 결합을 갖는 유연한 구조.jpg" alt="6-2_UserService 인터페이스 도입을 통해 약한 결합을 갖는 유연한 구조" style="zoom:50%;" />

    - 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 런타임 시에 DI를 통해 적용하는 방법
      - 사용 이유: 일반적으로 구현 클래스를 바꿔가면서 사용하기 위해.

  - 최종 조치 : 트랜잭션 경계설정을 위한 UserServiceTx의 도입.

    <img src="./img/6-2_트랜잭션 경계설정을 위한 UserServiceTx의 도입.jpg" alt="6-2_트랜잭션 경계설정을 위한 UserServiceTx의 도입" style="zoom:40%;" />

    - UserService를 구현한 또 다른 구현 클래스 UserServiceTx를 만든다.
      - 단지 트랜잭션의 결계설정이라는 책임을 맡고 있음.
      - 스스로 비즈니스 로직을 담고 있지 않기 때문에 또 다른 비즈니스 로직을 담고 있는 UserService의 구현클래스(UserServiceImpl)에 실제적인 로직 처리 작업은 위임하는 것.
      - 그 위임을 위한 호출 작업 이전과 이후에 적절한 트랜잭션 경계를 설정하면, 트랜잭션이 적용된 비즈니스 로직의 구현을 할 수 있음.

  ### 

#### UserService 인터페이스 도입

1. 기존의 UserService 클래스를 UserServiceImpl로 이름 변경

2. 클라이언트가 사용할 로직을 담은 핵심 메소드만 UserService 인터페이스로 만든 후 UserSerivceImpl이 구현하도록 만듬.

   - UserService 인터페이스

     ```java
     public interface UserService{
       void add(User user);
       void upgradeLevels();
     }
     ```

   - 트랜잭션 코드를 제거한 UserService 구현 클래스

     ```java
     public class UserServiceImpl implements UserService{
       UserDao userDao;
       MailSender mailSender;
       ...
         
     	public void upgradeLevels(){
         List<User> users = userDao.getAll();
         for(User user:users){
           if(canUpgradeLevel(user)){
             upgradeLevel(user);
           }
         }
           
       }
     }
     ```

     - UserService 인터페이스의 구현 클래스인 UserServiceImpl은 기존 UserService 클래스의 내용을 대부분 그대로 유지하면 됨.

       단,  트랜잭션 관련된 코드는 독립시키기로 했으니 모두 제거.

       

## 6.2 고립된 단위 테스트

### 6.2.3 단위 테스트와 통합테스트

#### 단위 테스트

- 중요한 것 : 하나의 단위에 초점을 맞춘 테스트라는 점.
- upgradeLevels() 테스트 처럼 '테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트 하는 것'.

#### 통합 테스트

- 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트 하거나 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트.
- 두 개이 상의 단위가 결합해섯 동작하면서 테스트가 수행되는 것.
  - 스프링의 테스트 컨텍스트 프레임워크를 이용해서 컨텍스트에서 생성되고 DI된 오브ㅔㄱ트를 테스트하는 것도 통합 테스트.

#### 단위 테스트와 통합 테스트 중에서 어떤 방법을 선택할 지에 대한 가이드라인.

- 항상 단위 테스트를 먼저 고려한다.

- 하나의 클래스나 성격과 목적이 같은 긴밀한 클래스 몇 개를 모아서 외부와의 의존관계를 모두 차단하고 필요에 따라 스텁이나 목 오브젝트 등의 테스트 대역을 이용하도록 테스트를 만든다.

  - 단위 테스트의 장점 : 가장  빠른시간에 효과적인 테스트를 작성하기에 유리함.
    - 왜? 테스트 작성도 간단하고 실행 속도도 빠르며 테스트 대상 외의 코드나 환경으로부터 테스트 결과에 영향을 받지않기때문에.

- 외부 리소스를 사용해야만 가능한  테스트는? 통합 테스트로 만든다.

- 단위 테스트로 만들기 어려운 코드가 있다.

  - 대표적인 코드 : DAO

    - DAO는 그 자체로 로직을 담고 있기보다는 DB를 통햏 로직을 수행하는 인터페이스와 같은 역할을 함.

      - DAO는 DB까지 연동하는 테스트로 만드는 편이 효과적.

        - 왜 ? SQL을 JDBC를 통해 실행하는 코드만으로는 고립된 테스트를 작성하기가 힘들다.

        작성한다고 해도 가치가 없는 경우가 대부분.

        →  DB를 사용하는 테스트는 DB에 테스트 데이터를 준비하고, DB에 직접 확인을 하는 등의 부가적인 작업 필요함.

- DAO 테스트:  통합 테스트로 분류 됨.

  - 왜? DB라는 외부 리소스를 사용하기 떄문.

  - 하지만, 코드에서 보자면 하나의 기능 단위를 테스트 하는 것이기도 함.

  - DAO를 테스트를 통해 충분히 검증해두면, DAO를 이용하는 코드느 DAO 역할을 스텁이나 목 오브ㅔㄱ트로 대체해서 테스트할 수 있음.

    이후에 실제 DAO와 연동했을 때도 바르게 동작하리라고 확신할 수 있음.

    물론 각각 단위 테스트가 성공했떠라도 여러 개의 단위를 연결해서 테스트ㅎ면 오류가 발생할 수도 잇음.

    하지만 충분한 단위 테스트를 거친다면 통합 테스트에서 오류가 발생할 확률도 죽어들고 발생한다고 하더라도 쉽게  처리할 수 있음.

- 여러개의 단위가 의존관계를 가지고 동작할 때를 위한 통합테스트는 필요하다.

  다만, 단위 테스트를 충분히 거쳤다면 통합 테스트의 부담은 상대적으로 줄어든다.

- 단위 테스트를 만들기가 복잡하다고 판단되는 코드는 처음부터 통합 테스트를 고려해 본다. 이때도 통합 테스트에 참여하는 코드 중에서 간으한 한 많은 부분을 미리 단위 테스트로 검증해두는 게 유리함.

- 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합테스트.

  - 가능하면 스프링의 지원 없이 직접 코드 레벨읭 DI를 사용하면서단위 테스트를 하는 게 좋겠지만 스프링의 설정 자체도 테스트 대상이고, 스프링을 이용해 좀 더 추상적인 레벨에서 테스트해야 할 경우도 종종 잇음.

     → 스프링의 테스트 컨텍스트  프레임워크를 이ㅇㅇ해 통합 테스트를 작성함.

    



