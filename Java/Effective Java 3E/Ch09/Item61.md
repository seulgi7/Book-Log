# 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라

## 자바의 데이터 타입

1. 기본 타입 : int, double, boolean

2. 참조 타입 : String, List]

   

## 박싱된 기본 타입 

각각의 기본 타입에는 대응하는 참조 타입이 하나씩 있음.

| 기본타입 | 박싱된 기본 타입 |
| -------- | ---------------- |
| int      | Integer          |
| double   | Double           |
| boolean  | Boolean          |



## 기본 타입과 박싱된 기본 타입의 주된 차이

오토박싱과 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수는 있지만(아이템6), 그렇다고 차이가 사라지는 것은 아니다. 

> 오토 박싱/언박싱 : 기본 타입과 박싱된 타입을 섞어 쓸 때 자동으로 상호 변환해주는 기술.
>
> >  JDK 1.5부터는 박싱과 언박싱이 필요한 상황에 자동으로 처리해줌.

둘 사이에는 분명한 차이가 있으니 어떤 타입을 사용하는지는 상당히 중요하다. 주의해서 선택해야 한다.

1. 기본 타입 : **값**만 가지고 있음.

   박싱된 기본 타입 : **값**에 더해 **식별성**(identify)이란 속성을 갖음.

   - 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있음.

2. 기본 타입 : 값은 언제나 **유효**함.

   박싱된 기본 타입 : **유효하지 않은** 값, 즉 null을 가질 수 있음.

3. **기본 타입**이 박싱된 기본 타입보다 **시간과 메모리 사용면에서 더 효율적**임.



###  (1) 기본 타임과 박싱된 기본 타입을 혼용한 예시

다음과 같이 Integer 값을 오름차순으로 정렬하는 비교자를 가정해보자.

```java
/* 첫 번째 원소가 두 번째 원소보다 작으면 음수,같으면 0,크면 양수 반환. */
Comparator<Integer> naturalOrder = 
  (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);

Systerm.out.println(naturalOrder.compare(new Integer(42), new Integer(42))); //0을 출력해야하지만, 실제로는 1을 출력함.
```

두 `Integer` 객체를 비교했을때, 숫자의 값이 같아서 `0`을 반환해야 할텐데 `1` 을 반환하는 이유는 무엇일까?

1. (i < j) :  false

- i와 j가 참조하는 오토박싱됨 Integer 인스턴스는 기본 타입 값으로 변환된 후 첫번째 정숫값이 두 번째 정숫값보다 작은지를 평가함.

- (i == j) :  false 
  - 두 번째 검사는 두 **객체 참조의 식별성**을 검사하게 됨.
  - i와 서로 다른 Integer 인스턴스라면 비록 값은 같더라고 false를 반환하게 됨.

즉, **박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어남.**



#### 해결

오토 박싱으로 검사 전에 바꾸어서 식별성 검사가 이루어지지 않게 하는 방법.

```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
  int i = iBoxed, j = jBoxed; //오토박싱
  return i<j ? -1 : (i == j ? 0 : 1);
}
```



### (2) 기본 타임과 박싱된 기본 타입을 혼용한 예시

```java
public cass Unbelievable {
	static Integer i;  // 예외 발생!
    
    public static void main(String[] args){
    	if (i == 42)
        	System.out.println("믿을 수 없군!");//NullPointerException
    }
}
```

`i == 42` 를 검사할때 `NullPointerException` 을 던지는 기이한 결과를 보여준다.

- 원인 : Integer가 다른 참조 타입 필드와 마찬가지로 초기값이`null` 이기 때문.

**거의 예외 없이 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.**

따라서 `null` 참조를 언박싱하게 되면 `NullPointerException`이 발생하는 것



### (3) 기본 타임과 박싱된 기본 타입을 혼용한 예시

```java
public static void main(String[] args) {
	Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
    	sum += i;
    }
    System.out.println(sum);
}
```

이 프로그램은 지역변수 `sum` 을 박싱된 기본 타입으로 선언하여 매우 느린 성능을 보여준다.
오류나 경고 없이 컴파일되지만, 박싱과 언박싱이 반복해서 일어나고 있기 때문이다.



## 박싱된 기본 타입의 용도

그렇다면 박싱된 기본 타입은 언제 써야할까?

1. 컬렉션의 원소, 키, 값으로 사용한다.
2. 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수에 사용한다.
3. 리플렉션을 통해 메서드를 호출할 때 사용한다.(아이템65)


>📚 **핵심 정리**
>기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 **가능한 기본 타입**을 사용하자. 박싱된 기본 타입을 써야 한다면, 다음의 세가지를 꼭 기억하자.
>
>1. 박싱된 기본 타입을 `==` 로 비교하면 식별성 검사가 이루어진다.
>2. 박싱된 기본 타입에서 기본 타입으로 언박싱하는 과정에서 `NullPointerException` 이 발생할 수 있다.
>3. 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용이 있다.


